/**
 * Project: DES++
 * $Header: $
 * Author: Christian Voth, Lennart Eikens, Lars Batterham, Steffen Kleinhaus
 * Last Change:
 *      by: $Author:
 *      date: $Date:
 * Copyright (c): DES++, 2020
 */

package statistics;

import core.LogHandler;
import core.Model;
import java.util.ArrayList;
import java.util.List;

/**
 * The class accumulate is used for collecting time-weighted data generated by queues.
 * It contains multiple Lists, one containing entry times and one containing exit times,
 */
public class Accumulate extends Statistic {

    /**
     * Reference to the Log-Handler.
     */
    private static final LogHandler myLog = new LogHandler();

    /**
     * Sorting instance used for sorting lists.
     */
    private Sorting sorting = new Sorting();

    /**
     * Arraylist containing ListEntries. Each ListEntry consists of a value, i.e. the queue size, and a reference to
     * the current simulation time.
     */
    private List<ListEntry> accumulate = new ArrayList<>();

    /**
     * Arraylist containing the time at which exists and entries occur.
     */
    private List<Double> timeOfChanges = new ArrayList<>();

    /**
     * Arraylist containing only the time of exists. Used for calculating queue time of a single entity.
     */
    private List<Double> timeOfExists = new ArrayList<>();

    /**
     * Keeps the total number of queue entries. Used to calculate
     */
    private double totalOfQueueEntries = 0;

    /**
     *
     * @param parentModel : reference to the associated model
     * @param name : name of accumulate instance
     */
    public Accumulate(Model parentModel, String name) {
        super(parentModel, name);
    }

    /**
     *
     * Creates a new ListEntry with the passed with value and the current simulation time
     * @param val : value passed in as queue length
     */
    public void update(double val) {

        ListEntry entry = new ListEntry(val, getModel().currentTime());
        accumulate.add(entry);
        super.update(val);
    }

    /**
     * Increased total number of queue entries
     */
    public void incTotalOfQueueEntries() {
        totalOfQueueEntries++;
    }

    /**
     *  Method checks list size concerning evenness. Calculates Quantiles accordingly.
     * @return quantile object containing the calculated first quantile, median and third quantile.
     */
    public Quantiles getQuantiles() {

        double median;

        double firstQuantile;

        double thirdQuantile;

        if (accumulate.size() <= 0) {
            return null;
        }
        calculateTimeDifferences();

        sorting.sortList(timeOfChanges);

        int npFirstQuantile = (int) (timeOfChanges.size() * 0.25d);
        int npThirdQuantile = (int) (timeOfChanges.size() * 0.75d);

        if (timeOfChanges.size() % 2 != 0) {
            median = timeOfChanges.get((timeOfChanges.size() / 2));
            firstQuantile = timeOfChanges.get(npFirstQuantile);
            thirdQuantile = timeOfChanges.get(npThirdQuantile);
        } else {
            median = (timeOfChanges.get((timeOfChanges.size() / 2))
                    + timeOfChanges.get(timeOfChanges.size() / 2 - 1)) * 0.5d;
            firstQuantile = (timeOfChanges.get(npFirstQuantile)
                    + timeOfChanges.get((npFirstQuantile - 1)) * 0.5d);
            thirdQuantile = (timeOfChanges.get(npThirdQuantile)
                    + timeOfChanges.get((npThirdQuantile - 1)) * 0.5d);
        }

        myLog.logger.finer("Value of Median: " + median + "FirstQuantile: " + firstQuantile
                        + " thirdQuantile: " + thirdQuantile);

        return new Quantiles(median, firstQuantile, thirdQuantile);



    }

    /**
     * Weighs list values with the time of change, resulting in a time weighted mean, used for waiting times.
     * @return the mean value of a list
     */
    public double getMean() {
        double timeWeightedSum = 0;

        for (int i = 0; i < accumulate.size() - 1; i++) {
            timeWeightedSum += accumulate.get(i).value
                    * (accumulate.get(i + 1).timeOfChange
                    - accumulate.get(i).timeOfChange);

        }
        myLog.logger.finer("timeWeightedSum Value: " + timeWeightedSum
                + "totalOfQuueueEntries: " + totalOfQueueEntries);
        return timeWeightedSum / totalOfQueueEntries;
    }

    /**
     * Basic calculation of the standard deviation.
     * @return the standard deviation from a given mean.
     */
    public double getStdDev() {

        double intermediateResult = 0;


            for (int i = 0; i < accumulate.size() - 1; i++) {
                intermediateResult += (Math.pow(accumulate.get(i).value
                        - getMean(), 2));
            }

            myLog.logger.finer("itermediateResult Value: " + intermediateResult
                    + "totalOfQuueueEntries: " + totalOfQueueEntries);

        return Math.sqrt(intermediateResult
                / (totalOfQueueEntries - 1));
        //-1 because we are dealing with samples
    }

    /**
     *
     * @return the smallest value in the list of changes
     */
    public double getMinimumWaitTime() {

        //calculateTimeDifferences();
        sorting.sortList(timeOfChanges);
        return timeOfChanges.get(0);


    }

    /**
     *
     * @return the largest value in the list of changes
     */
    public double getMaximumWaitTime() {

        //calculateTimeDifferences();
        sorting.sortList(timeOfChanges);
        return timeOfChanges.get(timeOfChanges.size() - 1);
    }

    /**
     * Calculates time difference between the entry time and the exit time of one entity. Saves these values in the
     * list time of changes.
     */
    public void calculateTimeDifferences() {

        findExits();

        try {


        if (accumulate.size() > 0) {

            for (int i = 1; i < accumulate.size() - 1; i++) {

                if (accumulate.get(i).value > accumulate.get(i - 1).value && timeOfExists.size() > 0) {

                    double timeOfEntry = accumulate.get(i).timeOfChange;
                    double timeOfExit = timeOfExists.get(0);

                    timeOfExists.remove(timeOfExit);
                    timeOfChanges.add(timeOfExit - timeOfEntry);
                    }

                }
            } } catch (IndexOutOfBoundsException exception) {
                myLog.logger.severe("calculateTimeDifferences Method as thrown an OutOfBoundsException: " + exception
                        + "Your timeOfChanges seems to be null");
        }
        }

    /**
     *
     * @return the list time of changes
     */
    public List getTimeOfChanges() {
        calculateTimeDifferences();
        sorting.sortList(timeOfChanges);
        return timeOfChanges;
    }

    /**
     * Runs through accumulate to find all exits and when they occur.
     */
    public void findExits() {
        try {


        for (int i = 1; i < accumulate.size() - 1; i++) {
            if (accumulate.get(i).value < accumulate.get(i - 1).value) {
                timeOfExists.add(accumulate.get(i).timeOfChange);
            }
        } } catch (IndexOutOfBoundsException exception) {
            myLog.logger.severe("findExits Method as thrown an OutOfBoundsException: " + exception
                + "Your timeOfExists seems to be null");
        }
    }

    /**
     * Adds default value to the list so that findexists() can run smoothly and does not result in an out of bounds
     * error.
     */
    public void initQueue() {
        ListEntry defaultEntry = new ListEntry(0,0);
        accumulate.add(defaultEntry);

    }

    /**
     *
     * @return WaitingTimeReport containing each significant value concerning queue waiting times.
     */
    @Override
    public WaitingTimeReport getQueueReport() {
        return new WaitingTimeReport(getMean(), getQuantiles(),
                getMinimumWaitTime(), getMaximumWaitTime());
    }

    @Override
    public Report getReport() {
        return null;
    }
}
